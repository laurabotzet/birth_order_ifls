---
author: "Laura Botzet"
date: "9/15/2016"
output:
  html_document:
    lib_dir: library
    self_contained: no
  pdf_document: default
---

# Data import {.tabset}

## Library
```{r Library}
library(formr)
library(devtools)
library(haven)
# devtools::install_github("hadley/haven")
library(plyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(dplyr)
```

## Helper
```{r}
all_available_info_birth_date = function(byear, bmonth, bday = NULL) {
  if(!is.null(bday)) {
    bday = paste0("-", bday)
  } else {
    bday = ""
  }
  ifelse(is.na(byear), NA,
         paste0(byear, "-", bmonth, bday))
  # can yield 2016-NA-NA
  #           2016-01-NA
  #           2016-01-01
  #           2016-01
}

#' ##### only older sibs
older_sibs_alive_and_dependent = function(byear, dyear) {
	sibs = length(byear)
	older_sibs_alive_and_dependent = integer(length=sibs)
	for(i in 1:sibs) {
		older_sibs = byear <= byear[i] # not using < because of twins
		older_sibs[i] = F # minus self
		my_sibs = sum(older_sibs,na.rm = T) # minus self
		if(my_sibs > 0) {
			sib_births = byear[ which(older_sibs) ]
			sib_deaths = dyear[ which(older_sibs) ]
			my_sibs = my_sibs -
				sum(
					# sib_births < (byear[i] - 5) | # others born more than 5y earlier than me  # 10 seconds of 17
						(sib_deaths <= byear[i]) # died before my birth
				,na.rm=T)
			older_sibs_alive_and_dependent[i] = my_sibs
		}
	}
	older_sibs_alive_and_dependent
}

```



## Load data
```{r Load data}
### Individual and household Information
## Informations about individuals living in the household in 2014/2015
# Individuals living in the household
bk_ar1 = read_dta("data/hh14_all_dta/bk_ar1.dta")
# Additional information from mothers
b4_ba6 = read_dta("data/hh14_all_dta/b4_ba6.dta")

# compute father pidlink
bk_ar1 = left_join(bk_ar1, bk_ar1 %>% select(hhid14_9, pid14, pidlink) %>% rename(ar10 = pid14, father_pidlink = pidlink), by = c("hhid14_9", "ar10"))
# compute mother pidlink
bk_ar1 = left_join(bk_ar1, bk_ar1 %>% select(hhid14_9, pid14, pidlink) %>% rename(ar11 = pid14, mother_pidlink = pidlink), by = c("hhid14_9", "ar11"))

### Informations about earlier waves
ptrack = read_dta("data/hh14_all_dta/ptrack.dta")

### IQ Information
ek_ek2 = read_dta("data/hh14_all_dta/ek_ek2.dta") # over 15yo
ek_time2 = read_dta("data/hh14_all_dta/ek_time2.dta")
# additional information (counting backwards, adaptive testing) for adults
b3b_cob = read_dta("data/hh14_all_dta/b3b_cob.dta") # over 15yo
b3b_co1 = read_dta("data/hh14_all_dta/b3b_co1.dta") # over 15yo
### Personality Information (only for adults)
b3b_psn = read_dta("data/hh14_all_dta/b3b_psn.dta") # over 15yo

### Risk taking
b3a_si = read_dta("data/hh14_all_dta/b3a_si.dta")

```



## Select individual data
```{r select individual data}
### Individuals
individuals = bk_ar1 %>% select(hhid14_9, pidlink, father_pidlink, mother_pidlink, ar01a, ar02b, ar10, ar11, ar07, ar08day, ar08mth, ar08yr, ar09, ar18h)
#Rename variables to make it easier
individuals <- rename(individuals, relation_to_HH_head = ar02b, fatherID = ar10, motherID = ar11, sex = ar07, age = ar09, alive = ar18h, status = ar01a) 
# Remove duplicats:
table(duplicated(individuals$pidlink))
individuals <- individuals %>% distinct(pidlink, .keep_all = TRUE)


## people whose parents can not be identified have to be marked as NA:
individuals$fatherID[ individuals$fatherID>50] = NA
individuals$motherID[ individuals$motherID>50] = NA

##create number that should be identical for all siblings in one family
individuals <- unite(individuals,
                  col = "hhid14_9_fatherID_motherID",
                  hhid14_9, fatherID, motherID,
                  sep = "_",
                  remove = FALSE)
individuals$hhid14_9_fatherID_motherID = ifelse(is.na(individuals$fatherID), NA, individuals$hhid14_9_fatherID_motherID)
individuals$hhid14_9_fatherID_motherID = ifelse(is.na(individuals$motherID), NA, individuals$hhid14_9_fatherID_motherID)

individuals = individuals %>% mutate(
  mother_father_dyad = stringr::str_c(father_pidlink, mother_pidlink)
)

crosstabs( ~ is.na(mother_father_dyad) + is.na(hhid14_9_fatherID_motherID), data = individuals)
n_distinct(individuals$mother_father_dyad)
n_distinct(individuals$hhid14_9_fatherID_motherID)


##calculate sibling size
individuals = individuals %>% 
   group_by(mother_father_dyad) %>%
   mutate(siblingcount = n())
individuals$siblingcount = ifelse(is.na(individuals$fatherID), NA, individuals$siblingcount)
individuals$siblingcount = ifelse(is.na(individuals$motherID), NA, individuals$siblingcount)
qplot(individuals$siblingcount)

##calculate birth order
# create date of birth
individuals$ar08day[ individuals$ar08day>31] = NA
individuals$ar08mth[ individuals$ar08mth>12] = NA
individuals$ar08yr[ individuals$ar08yr>2016] = NA
individuals$ar08day[ is.nan(individuals$ar08day) ] = NA
individuals$ar08mth[ is.nan(individuals$ar08mth) ] = NA
individuals$ar08yr[ is.nan(individuals$ar08yr)] = NA

individuals = individuals %>%
    mutate(birth = 
           ifelse(is.na(ar08yr), NA,
           paste0(ar08yr, "-", ar08mth, "-", ar08day)
           )
  ) %>%
  group_by(mother_father_dyad) %>%
  mutate(birthorder = min_rank(birth)) %>%
  group_by(mother_father_dyad, birth) %>%
  mutate(multiple_birth = n()) %>%
  group_by(mother_father_dyad) %>%
  mutate(any_multiple_birth_in_fam = any(multiple_birth > 1))

individuals$birthorder = ifelse(is.na(individuals$mother_father_dyad), NA, individuals$birthorder)
individuals$multiple_birth = ifelse(is.na(individuals$mother_father_dyad), NA, individuals$multiple_birth)
individuals$any_multiple_birth_in_fam = ifelse(is.na(individuals$mother_father_dyad), NA, individuals$any_multiple_birth_in_fam)


crosstabs(individuals$birthorder)
crosstabs(individuals$multiple_birth)
crosstabs(individuals[!duplicated(individuals$mother_father_dyad), ]$any_multiple_birth_in_fam)

# only few individuals with missing byears
crosstabs(~ is.na(ar08yr) + is.na(age), data = individuals)

qplot(individuals$birthorder)
```

## Compare with mother information
```{r compare with mother information}
motherinformations = b4_ba6 %>% select(hhid14_9, pidlink, ba63cx, ba64, ba64bmt, ba64byr, ba64c, ba65, ba65mt, ba65ayr, ba66, ba63n)

#Rename variables to make it easier
motherinformations <- rename(motherinformations, biologicalchild_m = ba63cx, sex_m = ba64,  birth_month_m = ba64bmt, birth_year_m = ba64byr, living_in_HH_m = ba64c, alive_m = ba65, death_month_m = ba65mt, death_year_m = ba65ayr, death_age_m = ba66,total_number_childs_m = ba63n, mother_pidlink = pidlink) 

# Mothercheck
individuals$mother_reported_on_other_sibs = ifelse(individuals$mother_pidlink %in% motherinformations$mother_pidlink, 1, 0)
crosstabs(individuals$mother_reported_on_other_sibs)

motherinformations$birth_year_m = (ifelse(motherinformations$birth_year_m<2016, motherinformations$birth_year_m, NA))

motherinformations$birth_month_m = (ifelse(motherinformations$birth_month_m<13, motherinformations$birth_month_m, NA))

motherinformations$death_year_m = (ifelse(motherinformations$death_year_m<2016, motherinformations$death_year_m, NA))

motherinformations$death_month_m = (ifelse(motherinformations$death_month_m<13, motherinformations$death_month_m, NA))

missingness_patterns(motherinformations %>% select(mother_pidlink, birth_year_m, birth_month_m))

motherinformations = motherinformations %>%
    mutate(mother_birthdate = str_c(mother_pidlink, 
          all_available_info_birth_date(birth_year_m, birth_month_m) ))

# remove all with unknown mothers/unknown birthmonths
motherinformations = motherinformations %>%
  filter(!is.na(mother_birthdate))

individuals = individuals %>%
    mutate(mother_birthdate = str_c(mother_pidlink, 
          all_available_info_birth_date(ar08yr, ar08mth) ))

# remove all with unknown mothers/unknown birthmonths
crosstabs(~ is.na(mother_birthdate) + mother_reported_on_other_sibs, data = individuals)

individuals = individuals %>%
  filter(!is.na(mother_birthdate), mother_reported_on_other_sibs == 1)


# overlap between individuals and motherinfo
length(intersect(individuals$mother_birthdate, motherinformations$mother_birthdate))

ind_mbd = na.omit(individuals$mother_birthdate)
ind_dupes = unique(ind_mbd[duplicated(ind_mbd)])
length(ind_dupes)
minfo_mbd = na.omit(motherinformations$mother_birthdate)
minfo_dupes = unique(minfo_mbd[duplicated(minfo_mbd)])
length(minfo_dupes)
# overlap between duplicates in ind and minfo
intersect(minfo_dupes, ind_dupes)
# suboptimal solution: because twins and triplets are not uniquely identified in the motherinformations file. We're using the mother informations file mainly to get sibs MISSING from the indidivuals file, so this is not a big deal. We also get death dates > 12m ago from the minfo file, but individuals who died >12m ago are not in the individuals file.
motherinformations = motherinformations %>% filter(! mother_birthdate %in% intersect(minfo_dupes, ind_dupes))

length(union(motherinformations$mother_birthdate, individuals$mother_birthdate)) # expected size of parentscheck minus twins
parentscheck = full_join(individuals, motherinformations, by = "mother_birthdate")
nrow(parentscheck)

parentscheck = parentscheck %>% aggregate2sources("mother_pidlink", "mother_pidlink.x", "mother_pidlink.y")

parentscheck = parentscheck %>%
  filter(!is.na(mother_birthdate), !is.na(mother_pidlink))


bk_ar1$ar18h = as.numeric(as.character(bk_ar1$ar18h))
bk_ar1$ar18h[is.nan(bk_ar1$ar18h)] = NA
crosstabs(~ ar01a + ar18h, data = bk_ar1)
crosstabs(~ bk_ar1$ar01a)
crosstabs(parentscheck$alive_m + parentscheck$status) # almost no one died in last12m?
### Social Birthorder - siblings by the time of birth
parentscheck$alive_m = ifelse(is.na(parentscheck$alive_m), 1, parentscheck$alive_m)
qplot(parentscheck$alive_m)

qplot(parentscheck$death_age_m, binwidth=1)
# all who're dead in our subset have their death date in minfo
parentscheck = parentscheck %>% mutate(
  death_year_m_agg = ifelse(is.na(death_year_m), birth_year_m + death_age_m, death_year_m),
  death_date = all_available_info_birth_date(death_year_m_agg, death_month_m))

### Biological Birthorder: Order in Uterus
# only include biological childs
parentscheck$biologicalchild_m = ifelse(
  is.na(parentscheck$biologicalchild_m), 1, # those who don't have this var are from the individuals file and are biological kids
  parentscheck$biologicalchild_m) # the ones from the minfo file can have a zero here (be adopted)

parentscheck = parentscheck %>%
    mutate(birth_ind = all_available_info_birth_date(ar08yr, ar08mth, ar08day),
           birth_minfo = all_available_info_birth_date(birth_year_m, birth_month_m)) %>%
    aggregate2sources("birth", "birth_ind", "birth_minfo")

parentscheck = parentscheck %>%
  group_by(mother_pidlink) %>%
  mutate(
    birth_bio = ifelse(biologicalchild_m == 1, birth, NA),
    birthorder_uterus = min_rank(birth_bio),
    siblingcount_maternal = sum(biologicalchild_m == 1),
    
    born_lived_5y = ifelse(death_age_m <= 5, NA, birth),
    birthorder_min5y = min_rank(born_lived_5y),
    siblingcount_min5y = sum(is.na(born_lived_5y)),
    
    birthorder_alive = older_sibs_alive_and_dependent(as.numeric(str_sub(birth, 1, 4)), death_year_m)
    
  ) %>%
  group_by(mother_pidlink, birth) %>% # adopt
  mutate(multiple_birth = sum(biologicalchild_m == 1)) %>%
  group_by(mother_pidlink) %>%
  mutate(any_multiple_birth_in_fam = any(multiple_birth > 1))

ggplot(parentscheck, aes(x=siblingcount_maternal, y=birthorder_uterus)) + geom_jitter()
ggplot(parentscheck, aes(x=siblingcount_maternal, y=birthorder_uterus)) + geom_jitter()

# how to compute social birth order
# count only those who're alive at own time of birth?
# count only those who survived their own infancy?

crosstabs(parentscheck$birthorder_min5y)
qplot(parentscheck$birthorder_min5y, parentscheck$birthorder_uterus, geom = 'jitter')
crosstabs(~ birthorder_min5y + birthorder_uterus, data = parentscheck)
crosstabs(~ birthorder_alive + birthorder_uterus, data = parentscheck)
qplot(parentscheck$birthorder_alive, parentscheck$birthorder_uterus, geom = 'jitter')

table(parentscheck$living_in_HH_m==3)

parentscheck = parentscheck %>% 
   group_by(mother_pidlink) %>%
   mutate(siblingcount_total = n())



individuals_parents_checked = filter(parentscheck, age>14)
```

## Select IQ data
```{r select IQ data}
### IQ Informations
##ek2 (>14yrs)
iq2.1 = ek_ek2 %>% select(hhid14_9, pidlink, age, sex, ektype, resptype, result, reason, ek1_ans, ek2_ans, ek3_ans, ek4_ans, ek5_ans, ek6_ans, ek7_ans, ek8_ans, ek9_ans, ek10_ans, ek11_ans, ek12_ans, ek13_ans, ek14_ans, ek15_ans, ek16_ans, ek17_ans, ek18_ans, ek19_ans, ek20_ans, ek21_ans, ek22_ans)


##additional informations for adults: counting backwards
iq2.2 = b3b_co1 %>% select(hhid14_9, pidlink, co04a, co04b, co04c, co04d, co04e, co07count, co10count)
##additional informations for adults: adaptive number test
iq2.3 = b3b_cob %>% select(hhid14_9, pidlink, w_abil, cob18, cob19b)

## put all the informations for participants >= 15 together
iq2 = full_join(iq2.1, iq2.2, by = "pidlink")
iq2 = full_join(iq2, iq2.3, by = "pidlink")
iq = iq2
iq <- plyr::rename(iq, c("age"="IQage")) 

### calculate iq scores
##Raven Test
answered_raven_items = iq %>% select(ek1_ans:ek6_ans, ek11_ans, ek12_ans)
psych::alpha(data.frame(answered_raven_items))
iq$raven = rowMeans( answered_raven_items, na.rm = T)
iq$raven[! iq$result %in% 1:2] = NA
qplot(iq$raven)

##Math Test
answered_math_items = iq %>% select(ek18_ans:ek22_ans)
psych::alpha(data.frame(answered_math_items))
iq$math = rowMeans( answered_math_items, na.rm = T)
iq$math[! iq$result %in% 1:2] = NA
qplot(iq$math)

##Counting Items
# Create Right/Wrong Scores for the counting items
iq$co04aright = as.numeric(iq$co04a == 93)
iq$co04bright = as.numeric(iq$co04b == iq$co04a-7)
iq$co04cright = as.numeric(iq$co04c == iq$co04b-7)
iq$co04dright = as.numeric(iq$co04d == iq$co04c-7)
iq$co04eright = as.numeric(iq$co04e == iq$co04d-7)

answered_counting_items = iq %>% select(co04aright:co04eright)
psych::alpha(data.frame(answered_counting_items))
iq$count_backwards = rowSums( answered_counting_items, na.rm = T) / 5
qplot(iq$count_backwards)

## Word Memory
iq$words_immediate = iq$co07count
iq$words_delayed = iq$co10count
qplot(iq$words_immediate, iq$words_delayed, geom = "jitter")
answered_word_items = iq %>% select(co07count,co10count)
psych::alpha(data.frame(answered_word_items))
iq$words_remembered_avg = rowMeans( answered_word_items, na.rm = T)
qplot(iq$words_remembered_avg)

##Adaptive Numbering
iq$adaptive_numbering = iq$w_abil


#iq$drew_pentagons = as.numeric(iq$cob19b == 1)
#iq$number_of_animals = iq$cob18

## Correlation of all Iq-Tests
round(cor(iq %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering), use = "pairwise.complete.obs"), 2)

##Missingness_Patterns
formr::missingness_patterns(iq %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering))

```

## compute g factor
```{r}
library(psych)
fa.parallel(iq %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering) %>% data.frame())
fa(iq %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering) %>% data.frame())
omega(iq %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering) %>% data.frame())

library(lavaan)
iq$adaptive_numbering = iq$adaptive_numbering/100
"g_factor =~ raven + math + count_backwards +  words_delayed+ adaptive_numbering" %>%
  cfa(missing = "fiml", data = iq) -> cfa_g
summary(cfa_g)

iq$g_factor = predict(cfa_g)[,1]
qplot(iq$g_factor)
round(cor(iq %>% select(g_factor, raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering), use = "pairwise.complete.obs"), 2)

formr::missingness_patterns(iq %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering, g_factor)) ## oops, lavaan only predicts the g factor for complete cases
```


## Select personality data
```{r select pesonality data}
### Personality
##Rearrange personality data so that every individual has only one row
pers = spread(b3b_psn, psntype, psn01)
##name columns
colnames(pers) <- c("hhid14_9", "pid14", "hhid14", "pidlink", "version", "module", "e1", "c1", "o1", "e2r", "n1r", "a1", "n2r", "o2", "c2r", "o3", "a2", "c3", "e3", "a3r", "n3")
pers = pers %>% select(hhid14_9, pidlink, e1, c1, o1, e2r, n1r, a1, n2r, o2, c2r, o3, a2, c3, e3, a3r, n3)

##Extraversion
pers$e2r_reversed = 6 - pers$e2r
extraversion = pers %>% select(e1, e2r_reversed, e3)
psych::alpha(data.frame(extraversion), check.keys = T)
pers$big5_ext = rowMeans(extraversion)
qplot(pers$big5_ext)

##conscientiousness
pers$c2r_reversed = 6 - pers$c2r
conscientiousness = pers %>% select(c1, c2r_reversed, c3)
psych::alpha(data.frame(conscientiousness), check.keys = T)
pers$big5_con = rowMeans(conscientiousness)
qplot(pers$big5_con)

##Openness
openness = pers %>% select(o1, o2, o3)
psych::alpha(data.frame(openness), check.keys = T)
pers$big5_open = rowMeans(openness)
qplot(pers$big5_open)

## Neuroticism
pers$n1r_reversed = 6 - pers$n1r
pers$n2r_reversed = 6 - pers$n2r
neuroticism = pers %>% select(n1r_reversed, n2r_reversed, n3)
pers$big5_neu = rowMeans(neuroticism)
qplot(pers$big5_neu)

##Agreeableness
pers$a3r_reversed = 6- pers$a3r
agreeableness= pers %>% select(a1, a2, a3r_reversed)
pers$big5_agree = rowMeans(agreeableness)
qplot(pers$big5_agree)
```


## Select risk taking data
```{r select risk taking data}
###Risktaking
risk = b3a_si %>% select(hhid14_9, pidlink, random_si, si01, si02, si03, si04, si05, si11, si12, si13, si14, si15)

## 8 means they didnt know which answer they would choose
risk$si01[ risk$si01 == 8] = NA
risk$si02[ risk$si02 == 8] = NA
risk$si03[ risk$si03 == 8] = NA
risk$si04[ risk$si04 == 8] = NA
risk$si05[ risk$si05 == 8] = NA
risk$si11[ risk$si11 == 8] = NA
risk$si12[ risk$si12 == 8] = NA
risk$si13[ risk$si13 == 8] = NA
risk$si14[ risk$si14 == 8] = NA
risk$si15[ risk$si15 == 8] = NA

## calculate a risk score for risk game A 
# (5 = gamble averse, Ordinalskala : 1 = risk loving, 4 = risk averse)
risk$riskA = ifelse(risk$si01 == 1 & risk$si02 == 1, 5,
             ifelse(risk$si01 == 2 & risk$si03 == 1 & risk$si04 == 1, 4,
             ifelse(risk$si01 == 2 & risk$si03 == 1 & risk$si04 == 2, 3,
             ifelse(risk$si01 == 2 & risk$si03 == 2 & risk$si05 == 1, 2,
             ifelse(risk$si01 == 2 & risk$si03 == 2 & risk$si05 == 2, 1,
             NA)))))
qplot(risk$riskA[risk$riskA != 5])

## calculate a risk score for risk game B 
# (5 = gamble averse, Ordinalskala : 1 = risk loving, 4 = risk averse)
risk$riskB = ifelse(risk$si11 == 2 & risk$si12 == 1, 5,
             ifelse(risk$si11 == 1 & risk$si13 == 1 & risk$si14 == 1, 4,
             ifelse(risk$si11 == 1 & risk$si13 == 1 & risk$si14 == 2, 3,
             ifelse(risk$si11 == 1 & risk$si13 == 2 & risk$si15 == 1, 2,
             ifelse(risk$si11 == 1 & risk$si13 == 2 & risk$si15 == 2, 1,
             NA)))))
qplot(risk$riskB[risk$riskB !=5])

psych::alpha(data.frame(risk %>% select(riskA, riskB)), check.keys = T)


```


## Merge data

```{r merge data}
### Merge ALL data (including all participants)
alldata = full_join(individuals_parents_checked, iq, by="pidlink")
alldata = full_join(alldata, pers, by="pidlink")
alldata = full_join(alldata, risk, by="pidlink")

### Merge PARENTS_CHECKED Data
#alldata_parents_checked = left_join(individuals_parents_checked, iq, by="pidlink")
#alldata_parents_checked = left_join(alldata_parents_checked, pers, by="pidlink")
#alldata_parents_checked = left_join(alldata_parents_checked, risk, by="pidlink")

#table(is.na(alldata_parents_checked$big5_ext))
```


## Calculate age related t-scores

```{r Calculate age related t-scores}
qplot(data = alldata, factor(age), raven, geom = "blank") + stat_summary( fun.data = "mean_sdl")

### IQ
alldata$raven_t <- 10*ave(alldata$raven, alldata$age, FUN=scale) + 50
qplot(alldata$raven_t)
alldata$math_t <- 10*ave(alldata$math, alldata$age, FUN=scale) + 50
qplot(alldata$math_t)
alldata$count_backwards_t <- 10*ave(alldata$count_backwards, alldata$age, FUN=scale) + 50
qplot(alldata$count_backwards_t)
alldata$words_immediate_t <- 10*ave(alldata$words_immediate, alldata$age, FUN=scale) + 50
qplot(alldata$words_immediate_t)
alldata$words_delayed_t <- 10*ave(alldata$words_delayed, alldata$age, FUN=scale) + 50
qplot(alldata$words_delayed_t)
alldata$adaptive_numbering_t <- 10*ave(alldata$adaptive_numbering, alldata$age, FUN=scale) + 50
qplot(alldata$adaptive_numbering_t)


### Personality
alldata$big5_ext_t <- 10*ave(alldata$big5_ext, alldata$age, FUN=scale) + 50
qplot(alldata$big5_ext_t)
alldata$big5_agree_t <- 10*ave(alldata$big5_agree, alldata$age, FUN=scale) + 50
qplot(alldata$big5_agree_t)
alldata$big5_open_t <- 10*ave(alldata$big5_open, alldata$age, FUN=scale) + 50
qplot(alldata$big5_open_t)
alldata$big5_con_t <- 10*ave(alldata$big5_con, alldata$age, FUN=scale) + 50
qplot(alldata$big5_con_t)
alldata$big5_neu_t <- 10*ave(alldata$big5_neu, alldata$age, FUN=scale) + 50
qplot(alldata$big5_neu_t)


###Risktaking (geht nicht, da es keine intervallskalierte Variable ist (nur 5 level))
```

## Exploring data

``` {r exploring data}
### Birth order and sibling size
ggplot(alldata, aes(x=siblingcount, y=birthorder)) + geom_jitter()
### Birth order and age
ggplot(alldata, aes(x=birthorder, y=age)) + geom_jitter() + coord_cartesian(ylim = c(0, 100))

### Personality
ggplot(alldata, aes(x=big5_agree, y=big5_neu)) + geom_jitter()

###Openness and Intelligence
round(cor(alldata %>% ungroup %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering, g_factor, big5_open), use = "pairwise.complete.obs"), 2)

###Other personality factors and Intelligence
round(cor(alldata %>% ungroup %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering, g_factor, big5_con), use = "pairwise.complete.obs"), 2)
round(cor(alldata %>% ungroup %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering, g_factor, big5_ext), use = "pairwise.complete.obs"), 2)
round(cor(alldata %>% ungroup %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering, g_factor, big5_agree), use = "pairwise.complete.obs"), 2)
round(cor(alldata %>% ungroup %>% select(raven, math, count_backwards, words_immediate, words_delayed, adaptive_numbering, g_factor, big5_neu), use = "pairwise.complete.obs"), 2)
# Opennes has the highest values!
ggplot(alldata, aes(x=big5_open, y=g_factor)) + geom_jitter() + geom_smooth(method=lm) 
```


## Save data

for future analyses

```{r save data}
saveRDS(alldata, file = "data/all.rds")

```